<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ã˜ã‚ƒã‚“ã‘ã‚“AI ã‚­ã‚¸ãƒ ãƒ³</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* ----- ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—å‘ã‘ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆå…ƒã®ã¾ã¾ï¼‰ ----- */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f0f2f5;
      margin: 0;
      padding: 20px;
      color: #333;
    }
    #game-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-around;
      align-items: flex-start;
      background-color: #fff;
      padding: 25px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      max-width: 1000px;
      margin: auto;
    }
    #left-panel, #right-panel {
      flex: 1;
      min-width: 400px;
      margin: 10px;
    }
    #left-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #right-panel {
      margin-top: 0px;
    }
    h1 {
      color: #1d4ed8;
      text-align: center;
      margin-bottom: 20px;
    }
    .section-title {
      font-size: 18px;
      font-weight: bold;
      color: #4b5563;
      margin-top: 20px;
      margin-bottom: 10px;
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 5px;
    }
    .choice-btn {
      font-size: 26px;
      padding: 12px 25px;
      margin: 8px;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      background-color: #e5e7eb;
      transition: background-color 0.2s, transform 0.1s;
    }
    .choice-btn:hover { background-color: #d1d5db; }
    .choice-btn:active { transform: scale(0.95); }
    .choice-btn:disabled { cursor: not-allowed; opacity: 0.6; }
    #bluff {
      font-size: 18px;
      margin-bottom: 15px;
      color: #c81e1e;
      min-height: 24px;
      font-weight: bold;
      text-align: center;
      background-color: #fee2e2;
      padding: 8px;
      border-radius: 5px;
      border: 1px solid #fca5a5;
    }
    #face-container { position: relative; margin-bottom: 15px; }
    #face {
      width: 200px;
      display: block;
      margin: 0 auto 10px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    #ai-reasoning {
      position: absolute;
      bottom: -20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s, visibility 0.3s;
      z-index: 10;
    }
    #face-container:hover #ai-reasoning {
      visibility: visible;
      opacity: 1;
    }
    #statusText {
      font-size: 36px;
      font-weight: bold;
      margin: 15px 0;
      text-align: center;
    }
    #result {
      margin-top: 10px;
      font-size: 20px;
      min-height: 24px;
      text-align: center;
      font-weight: 500;
    }
    #history {
      margin-top: 10px;
      font-size: 14px;
      color: #666;
      text-align: center;
    }
    #statsInfo {
      margin-top: 10px;
      font-size: 16px;
      color: #444;
      line-height: 1.6;
    }
    #settings {
      background-color: #f9fafb;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
      border: 1px solid #e5e7eb;
    }
    #settings label { margin-right: 10px; font-weight: 500; }
    #settings select,
    #settings input[type="checkbox"] { margin-right: 15px; }
    #debug-info {
      font-size: 12px;
      color: #6b7280;
      margin-top: 15px;
      line-height: 1.4;
      max-height: 100px;
      overflow-y: auto;
      border: 1px dashed #d1d5db;
      padding: 5px;
    }
    #buttons button {
      font-size: 24px;
      padding: 10px 20px;
      margin: 10px;
      font-family: Arial, sans-serif;
    }
    #buttons button:hover { background-color: #e0e0e0; }

    /* â†‘ã“ã“ã¾ã§å…ƒã®CSSâ†‘ */

    /* ãƒãƒ£ãƒ¼ãƒˆã‚’ç¸¦ã«åºƒã‚ã« */
    #statsChart{
      width: 100% !important;
      height: 280px !important;
    }
    #userHistChart {
      width: 50% !important;
      height: 280px !important;
      margin: 0 auto; /* ä¸­å¤®æƒãˆ */
      display: block; /* ä¸­å¤®æƒãˆã®ãŸã‚ã«å¿…è¦ */
    }

    /* ----- ã‚¹ãƒãƒ›å‘ã‘ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– ----- */
    @media (max-width: 600px) {
      body { padding: 10px; }
      #game-container {
        flex-direction: column;
        padding: 15px;
      }
      #left-panel, #right-panel {
        min-width: auto;
        width: 100%;
        margin: 15px 0;
      }
      h1 { font-size: 20px; line-height: 1.2; }
      .section-title { font-size: 16px; }
      .choice-btn { font-size: 20px; padding: 10px 18px; margin: 6px; }
      #statusText { font-size: 24px; }
      #result { font-size: 18px; }
      #history, #statsInfo { font-size: 14px; }
      #bluff { font-size: 16px; padding: 6px; }
      #face { width: 150px; }
      #settings { padding: 10px; }
      #settings label,
      #settings select,
      #settings input { font-size: 14px; }
      #debug-info { font-size: 10px; max-height: 80px; }
    #statsChart { 
      height: 200px !important; /* é«˜ã•ã‚’é©åˆ‡ã«èª¿æ•´ */
      width: 100% !important;    /* æ¨ªå¹…ã‚’90%ã«ã—ã¦ã‚¹ãƒãƒ›ç”»é¢ã«ãƒ•ã‚£ãƒƒãƒˆ */
      max-width: 400px;         /* æœ€å¤§å¹…ã‚’400pxã«åˆ¶é™ */
      margin: 20px auto;        /* ä¸Šä¸‹ä½™ç™½20pxã€ä¸­å¤®å¯„ã› */
      display: block;           /* ä¸­å¤®å¯„ã›ã®ãŸã‚ã«å¿…è¦ */
    }
    #userHistChart {
      width: 100% !important;    /* æ¨ªå¹…ã‚’90%ã«ã—ã¦å·¦å³ã«ä½™ç™½ */
      max-width: 400px;         /* å¿…è¦ãªã‚‰æœ€å¤§å¹…ã‚‚åˆ¶é™ */
      margin: 0px auto 20px;   /* ä¸Šä½™ç™½20pxã€ä¸‹ä½™ç™½20pxã€ä¸­å¤®å¯„ã› */
      display: block; /* ä¸­å¤®å¯„ã›ã®ãŸã‚ã«å¿…è¦ */
    }   
      }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="left-panel">
      <h1>VSãƒƒ!!ã˜ã‚ƒã‚“ã‘ã‚“ã‚­ã‚¸ãƒ ãƒ³ï¼ï¼<br>(å…ˆã«30å‹ã§å‹åˆ©ã•ãƒ¼ï¼)</h1>

      <div id="settings" style="margin-bottom: 20px; text-align: left;">
        <span class="section-title" style="border: none; margin-bottom: 5px;">è¨­å®š</span><br>
        <label for="difficulty">é›£æ˜“åº¦:</label>
        <select id="difficulty">
          <option value="easy">æ˜“ã—ã„</option>
          <option value="normal" selected>æ™®é€š</option>
          <option value="hard">é›£ã—ã„</option>
          <option value="veryhard">è¶…é›£ã—ã„</option>
        </select>
        <label for="show-reasoning">ã‚­ã‚¸ãƒ ãƒ³ã®è€ƒãˆã‚’è¦‹ã‚‹:</label>
        <input type="checkbox" id="show-reasoning">
      </div>
      <div id="bluff">ã‚­ã‚¸ãƒ ãƒ³: ã‚ˆãƒ¼ã—ã€ã˜ã‚ƒã‚“ã‘ã‚“ã™ã‚‹ã•ãƒ¼ï¼</div>
      <div id="face-container">
        <img id="face" src="" alt="ã‚­ã‚¸ãƒ ãƒ³ã®è¡¨æƒ…">
        <span id="ai-reasoning">ã‚­ã‚¸ãƒ ãƒ³ã®è€ƒãˆ</span>
        <div id="statusText">å‹è² ã•ãƒ¼ï¼</div>
        <div id="result">ã‚ãªãŸ vs ã‚­ã‚¸ãƒ ãƒ³</div>  
        <div id="hand-images" style="display:flex; justify-content:center; gap:20px; margin-top:10px;">
            <img id="user-hand" src="" alt="ã‚ãªãŸã®æ‰‹" width="80" height="80">
            <span style="font-size: 24px; font-weight: bold; align-self: center;">VS</span>
            <img id="ai-hand"   src="" alt="ã‚­ã‚¸ãƒ ãƒ³ã®æ‰‹" width="80" height="80">
        </div>
      </div>
      <div id="buttons" style="display: flex; justify-content: center; gap: 10px; margin-top: 10px;">
        <button class="choice-btn" data-choice="ã‚°ãƒ¼">ğŸ‘Š ã‚°ãƒ¼</button>
        <button class="choice-btn" data-choice="ãƒãƒ§ã‚­">âœŒï¸ ãƒãƒ§ã‚­</button>
        <button class="choice-btn" data-choice="ãƒ‘ãƒ¼">ğŸ–ï¸ ãƒ‘ãƒ¼</button>
      </div>

      <div id="history">å±¥æ­´: å‹ã¡(0), è² ã‘(0), ã‚ã„ã“(0)</div>
      <div id="statsInfo">
        å‹ç‡: ã‚ãªãŸ 0.0% / ã‚­ã‚¸ãƒ ãƒ³ 0.0%<br>
        æœ€å¤§é€£å‹: ã‚ãªãŸ 0 å›, ã‚­ã‚¸ãƒ ãƒ³ 0 å›<br>
        ç¾åœ¨ã®ãƒ‘ã‚¿ãƒ¼ãƒ³é•·: 1
      </div>
      <div id="debug-info" style="text-align: left;">ãƒ‡ãƒãƒƒã‚°æƒ…å ±:</div>
    </div>

    <div id="right-panel">
      <div class="section-title" style="margin-top: 0px;">çµ±è¨ˆã‚°ãƒ©ãƒ•</div>
      <canvas id="statsChart"></canvas>
      <div class="section-title" style="margin-top: 30px;">ã‚ãªãŸã®æ‰‹ã®å‚¾å‘</div>
      <canvas id="userHistChart"></canvas>
    </div>
  </div>

  <script>
    // --- å®šæ•°å®šç¾© ---
    const CHOICES = ['ã‚°ãƒ¼', 'ãƒãƒ§ã‚­', 'ãƒ‘ãƒ¼'];
    const COUNTER_MAP = { 'ã‚°ãƒ¼': 'ãƒ‘ãƒ¼', 'ãƒãƒ§ã‚­': 'ã‚°ãƒ¼', 'ãƒ‘ãƒ¼': 'ãƒãƒ§ã‚­' };
    const WIN_TARGET = 30;

    // --- æ‰‹ç”»åƒã® URL ãƒãƒƒãƒ—è¿½åŠ  ---
    const USER_HAND_IMAGES = {
    'ã‚°ãƒ¼':  'https://i.imgur.com/cLcVghg.png',
    'ãƒãƒ§ã‚­':'https://i.imgur.com/vKcKjfs.png',
    'ãƒ‘ãƒ¼':  'https://i.imgur.com/WrNhJFY.png'
    };
    const AI_HAND_IMAGES = {
    'ã‚°ãƒ¼':  'https://i.imgur.com/pddAFX0.png',
    'ãƒãƒ§ã‚­':'https://i.imgur.com/Ck8uJzj.png',
    'ãƒ‘ãƒ¼':  'https://i.imgur.com/hWtNynY.png'
    };
    const userHandEl = document.getElementById('user-hand');
    const aiHandEl   = document.getElementById('ai-hand');


    // é›£æ˜“åº¦åˆ¥ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ (å‰å›ã¨åŒã˜)
    const DIFFICULTY_SETTINGS = {
        easy:   { initialEpsilon: 0.7,  epsilonDecay: 0.99, minEpsilon: 0.2,  initialMaxPattern: 1, patternGrowthRate: 0.01, maxPatternCap: 2, adaptThreshold: 0.5, metaWeightPattern: 0.4, metaWeightFreq: 0.4, metaWeightWinLoss: 0.2 },
        normal: { initialEpsilon: 0.5,  epsilonDecay: 0.97, minEpsilon: 0.1,  initialMaxPattern: 2, patternGrowthRate: 0.02, maxPatternCap: 4, adaptThreshold: 0.3, metaWeightPattern: 0.5, metaWeightFreq: 0.3, metaWeightWinLoss: 0.2 },
        hard:   { initialEpsilon: 0.3,  epsilonDecay: 0.96, minEpsilon: 0.05, initialMaxPattern: 3, patternGrowthRate: 0.03, maxPatternCap: 5, adaptThreshold: 0.2, metaWeightPattern: 0.6, metaWeightFreq: 0.2, metaWeightWinLoss: 0.2 },
        veryhard:{ initialEpsilon: 0.2, epsilonDecay: 0.95, minEpsilon: 0.02, initialMaxPattern: 4, patternGrowthRate: 0.04, maxPatternCap: 6, adaptThreshold: 0.15, metaWeightPattern: 0.7, metaWeightFreq: 0.1, metaWeightWinLoss: 0.2 },
    };

    // === ç”»åƒURLã‚’ã”æŒ‡å®šã®ã‚‚ã®ã«å¤‰æ›´ ===
    const IMG_HAPPY     = 'https://i.imgur.com/XIwk5uc.png'; // AIå‹åˆ©
    const IMG_SAD       = 'https://i.imgur.com/pbDebFC.png'; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‹åˆ©
    const IMG_THINK     = 'https://i.imgur.com/VXzFi1K.png'; // ã‚ã„ã“ãƒ»è€ƒãˆä¸­
    const IMG_FINAL_USER = 'https://i.imgur.com/GcezINz.png'; // æœ€çµ‚çš„ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‹åˆ©
    const IMG_FINAL_AI  = 'https://i.imgur.com/8H6y3m0.png'; // æœ€çµ‚çš„ã«AIå‹åˆ©

    // --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° (å‰å›ã¨åŒã˜) ---
    let userHistory = { 'ã‚°ãƒ¼': 0, 'ãƒãƒ§ã‚­': 0, 'ãƒ‘ãƒ¼': 0 };
    let userSequence = [];
    let patternMap = {};
    let winLossHistory = [];
    let userWins = 0, aiWins = 0, draws = 0;
    let userStreak = 0, aiStreak = 0, maxUserStreak = 0, maxAiStreak = 0;
    let currentMaxPattern;
    let epsilon;
    let gameSettings;
    let lastUserDistribution = { 'ã‚°ãƒ¼': 0, 'ãƒãƒ§ã‚­': 0, 'ãƒ‘ãƒ¼': 0 };
    let roundsPlayed = 0;
    let aiReasoning = "";
    let strategicBluff = "";

    // --- UIè¦ç´  (å‰å›ã¨åŒã˜) ---
    const bluffEl = document.getElementById('bluff');
    const faceEl = document.getElementById('face');
    const aiReasoningEl = document.getElementById('ai-reasoning');
    const statusTextEl = document.getElementById('statusText');
    const resultEl = document.getElementById('result');
    const historyEl = document.getElementById('history');
    const statsInfoEl = document.getElementById('statsInfo');
    const debugInfoEl = document.getElementById('debug-info');
    const choiceBtns = document.querySelectorAll('.choice-btn');
    const difficultySelect = document.getElementById('difficulty');
    const showReasoningCheckbox = document.getElementById('show-reasoning');

    // --- Chart.js åˆæœŸåŒ– (ã“ã“ã«å¤‰æ›´ã¯ã‚ã‚Šã¾ã›ã‚“) ---
    const statsCtx = document.getElementById('statsChart').getContext('2d');
    let statsChart = null; // å¾Œã§åˆæœŸåŒ–
    const userHistCtx = document.getElementById('userHistChart').getContext('2d');
    let userHistChart = null; // å¾Œã§åˆæœŸåŒ–
    let committedAiChoice = null;

    function initializeCharts() {
    // æ—¢å­˜ã®ãƒãƒ£ãƒ¼ãƒˆãŒã‚ã‚Œã°ç ´æ£„
    if (statsChart)     statsChart.destroy();
  if (userHistChart)  userHistChart.destroy();

  const maxValue = Math.max(userWins, aiWins, draws);
 
  // æ£’ã‚°ãƒ©ãƒ•
  statsChart = new Chart(statsCtx, {
    type: 'bar',
    data: {
      labels: ['ã‚ãªãŸã®å‹ã¡', 'ã‚­ã‚¸ãƒ ãƒ³ã®å‹ã¡', 'ã‚ã„ã“'],
      datasets: [{
        label: 'å‹è² å›æ•°',
        data: [userWins, aiWins, draws],
        backgroundColor: ['#ef4444', '#3b82f6', '#6b7280']
      }]
    },
    options: {
      responsive: false,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          labels: {
            font: { size: 14 }   // å‡¡ä¾‹ã®æ–‡å­—ã‚µã‚¤ã‚ºå›ºå®š
          }
        }
      },
      scales: {
        x: {
          ticks: {
            font: { size: 12 }   // Xè»¸ãƒ©ãƒ™ãƒ«å›ºå®š
          }
        },
        y: {
          beginAtZero: true,
          suggestedMax: maxValue + 5, // Yè»¸ã®æœ€å¤§å€¤ã‚’è¨­å®š
          ticks: {
            precision: 0,
            font: { size: 12 }   // Yè»¸ãƒ©ãƒ™ãƒ«å›ºå®š
          }
        }
      },
      layout: {
        padding: {
          top: 10,
          bottom: 10
        }
      }
    }
  });

  // ãƒ‰ãƒ¼ãƒŠãƒ„ã‚°ãƒ©ãƒ•
  userHistChart = new Chart(userHistCtx, {
    type: 'doughnut',
    data: {
      labels: ['ã‚°ãƒ¼', 'ãƒãƒ§ã‚­', 'ãƒ‘ãƒ¼'],
      datasets: [{
        label: 'ã‚ãªãŸã®æ‰‹ã®å†…è¨³',
        data: [userHistory['ã‚°ãƒ¼'], userHistory['ãƒãƒ§ã‚­'], userHistory['ãƒ‘ãƒ¼']],
        backgroundColor: ['#f87171', '#fbbf24', '#34d399']
      }]
    },
    options: {
      responsive: false,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          labels: {
            font: { size: 14 }
          }
        },
        tooltip: {
          callbacks: {
            label: function(context) {
              const data = context.dataset.data;
              const total = data.reduce((s, v) => s + v, 0);
              const pct = total ? (context.parsed / total * 100).toFixed(1) : '0.0';
              return `${context.label}: ${pct}%`;
            }
          }
        }
      }
      // scales ã¯ãƒ‰ãƒ¼ãƒŠãƒ„ã«ä¸è¦ãªã®ã§çœç•¥
    }
  });
}



    // --- é–¢æ•°å®šç¾© ---

    /**
     * ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–ã¾ãŸã¯ãƒªã‚»ãƒƒãƒˆ
     */
    function initGame() {
        // å¤‰æ•°ãƒªã‚»ãƒƒãƒˆ
        committedAiChoice = null;  // â† è¿½åŠ 
        userHistory = { 'ã‚°ãƒ¼': 0, 'ãƒãƒ§ã‚­': 0, 'ãƒ‘ãƒ¼': 0 };
        userSequence = [];
        patternMap = {};
        winLossHistory = [];
        userWins = 0; aiWins = 0; draws = 0;
        userStreak = 0; aiStreak = 0; maxUserStreak = 0; maxAiStreak = 0;
        roundsPlayed = 0;
        lastUserDistribution = { 'ã‚°ãƒ¼': 0, 'ãƒãƒ§ã‚­': 0, 'ãƒ‘ãƒ¼': 0 };
        aiReasoning = "ã•ã‚ã€å§‹ã‚ã‚‹ã‚ˆãƒ¼ï¼";
        strategicBluff = "ã‚­ã‚¸ãƒ ãƒ³: ã‚ˆãƒ¼ã—ã€ã˜ã‚ƒã‚“ã‘ã‚“ã™ã‚‹ã•ãƒ¼ï¼";

        // é›£æ˜“åº¦è¨­å®š
        gameSettings = DIFFICULTY_SETTINGS[difficultySelect.value];
        epsilon = gameSettings.initialEpsilon;
        currentMaxPattern = gameSettings.initialMaxPattern;

        // UIåˆæœŸåŒ–
        initializeCharts(); // ãƒãƒ£ãƒ¼ãƒˆã‚‚ã“ã“ã§åˆæœŸåŒ–
        updateUI('å‹è² ã•ãƒ¼ï¼', '', '');
        faceEl.src = IMG_THINK;
        choiceBtns.forEach(btn => btn.disabled = false);
        debugLog("ã‚²ãƒ¼ãƒ åˆæœŸåŒ–å®Œäº†ã•ãƒ¼ã€‚é›£æ˜“åº¦: " + difficultySelect.value);
    }

    // debugLog é–¢æ•°ã¯å‰å›ã¨åŒã˜
     function debugLog(message) {
         const time = new Date().toLocaleTimeString();
         // Check if debugInfoEl exists before manipulating it
         if (debugInfoEl) {
             debugInfoEl.innerHTML = `[${time}] ${message}<br>` + debugInfoEl.innerHTML;
             const lines = debugInfoEl.innerHTML.split('<br>');
             if (lines.length > 51) {
                 debugInfoEl.innerHTML = lines.slice(0, 50).join('<br>');
             }
         } else {
             console.log(`[DEBUG] ${message}`); // Fallback to console if element not found
         }
     }


    // updateGameHistory é–¢æ•°ã¯å‰å›ã¨åŒã˜
     function updateGameHistory(userChoice) {
        userHistory[userChoice]++;
        userSequence.push(userChoice);
        if (userSequence.length > currentMaxPattern + 1) {
            userSequence.shift();
        }
        for (let len = 1; len <= Math.min(currentMaxPattern, userSequence.length - 1); len++) {
            const patternKey = userSequence.slice(-len - 1, -1).join('_');
            const nextChoice = userSequence[userSequence.length - 1];
            if (!patternMap[patternKey]) {
                patternMap[patternKey] = { 'ã‚°ãƒ¼': 0, 'ãƒãƒ§ã‚­': 0, 'ãƒ‘ãƒ¼': 0, 'count': 0 };
            }
            patternMap[patternKey][nextChoice]++;
            patternMap[patternKey]['count']++;
        }
    }

    // updateDynamicMaxPattern é–¢æ•°ã¯å‰å›ã¨åŒã˜
     function updateDynamicMaxPattern() {
         const potentialMaxPattern = Math.floor(gameSettings.initialMaxPattern + roundsPlayed * gameSettings.patternGrowthRate);
         currentMaxPattern = Math.min(potentialMaxPattern, gameSettings.maxPatternCap);
     }

    // detectStrategyChange é–¢æ•°ã¯å‰å›ã¨åŒã˜ï¼ˆãƒ­ã‚°ã®å£èª¿ã®ã¿å¤‰æ›´ï¼‰
    function detectStrategyChange() {
        if (roundsPlayed < 10) return false;
        const currentDistribution = {};
        let total = 0;
        for(const choice of CHOICES) {
            currentDistribution[choice] = userHistory[choice];
            total += userHistory[choice];
        }
        if (total === 0) return false;
        let diffSum = 0;
        for(const choice of CHOICES) {
            const currentRate = currentDistribution[choice] / total;
            const lastRate = (lastUserDistribution[choice] || 0) / (roundsPlayed -1 || 1) ;
            diffSum += Math.pow(currentRate - lastRate, 2);
        }
        const changeMagnitude = Math.sqrt(diffSum);
        lastUserDistribution = {...currentDistribution};

        debugLog(`æˆ¦ç•¥å¤‰åŒ–ãƒã‚§ãƒƒã‚¯: å¤‰åŒ–é‡=${changeMagnitude.toFixed(3)} (é–¾å€¤: ${gameSettings.adaptThreshold})`);

        if (changeMagnitude > gameSettings.adaptThreshold) {
            debugLog("ãŠã£ã¨ã€æ‰‹ã®å‡ºã—æ–¹ãŒå¤‰ã‚ã£ãŸã•ãƒ¼ï¼Ÿ ã¡ã‚‡ã£ã¨è€ƒãˆç›´ã™ã‚ˆãƒ¼ï¼ Epsilonä¸Šæ˜‡ï¼");
            epsilon = Math.min(1.0, epsilon * 1.5);
            return true;
        }
        return false;
    }

    // assessOpponentRandomness é–¢æ•°ã¯å‰å›ã¨åŒã˜ï¼ˆãƒ­ã‚°ã®å£èª¿ã®ã¿å¤‰æ›´ï¼‰
     function assessOpponentRandomness() {
         const total = roundsPlayed;
         if (total < 5) return 0.5;
         let entropy = 0;
         for (const choice of CHOICES) {
             const probability = userHistory[choice] / total;
             if (probability > 0) {
                 entropy -= probability * Math.log2(probability);
             }
         }
         const normalizedEntropy = entropy / Math.log2(3);
         debugLog(`ç›¸æ‰‹ã®ãƒ©ãƒ³ãƒ€ãƒ æ€§ãƒã‚§ãƒƒã‚¯: ${normalizedEntropy.toFixed(3)} (1ã«è¿‘ã„ã»ã©ãƒ©ãƒ³ãƒ€ãƒ ã•ãƒ¼)`);
         return normalizedEntropy;
     }


    // predictUserChoice é–¢æ•°ã¯å‰å›ã¨åŒã˜ï¼ˆãƒ­ã‚°ã®å£èª¿ã®ã¿å¤‰æ›´ï¼‰
    function predictUserChoice() {
        let predictions = {
            pattern: { choice: null, confidence: 0, reason: "æœ‰åŠ¹ãªãƒ‘ã‚¿ãƒ¼ãƒ³ãªã„ã•ãƒ¼" },
            frequency: { choice: null, confidence: 0, reason: "ã¾ã ãƒ‡ãƒ¼ã‚¿ãªã„ã•ãƒ¼" },
            winLoss: { choice: null, confidence: 0, reason: "å‹æ•—ãƒ‡ãƒ¼ã‚¿ãªã„ã•ãƒ¼" }
        };
        const totalPlays = roundsPlayed;
        let bestPatternReason = predictions.pattern.reason;

        for (let len = Math.min(userSequence.length, currentMaxPattern); len > 0; len--) {
            const patternKey = userSequence.slice(-len).join('_');
            if (patternMap[patternKey] && patternMap[patternKey]['count'] > 1) {
                const counts = patternMap[patternKey];
                let predicted = 'ã‚°ãƒ¼';
                if (counts['ãƒãƒ§ã‚­'] > counts[predicted]) predicted = 'ãƒãƒ§ã‚­';
                if (counts['ãƒ‘ãƒ¼'] > counts[predicted]) predicted = 'ãƒ‘ãƒ¼';
                const confidence = (counts[predicted] / counts['count']) * (Math.log(counts['count'] + 1) / Math.log(totalPlays + 2));
                if(confidence > predictions.pattern.confidence){
                   const reason = `ãƒ‘ã‚¿ãƒ¼ãƒ³(${patternKey})ã‹ã‚‰äºˆæ¸¬ (ä¿¡é ¼åº¦: ${confidence.toFixed(2)})`;
                   predictions.pattern = { choice: predicted, confidence: confidence, reason: reason };
                   bestPatternReason = reason;
                }
            }
        }
         predictions.pattern.reason = bestPatternReason;


        if (totalPlays > 0) {
            let mostFrequent = 'ã‚°ãƒ¼';
            if (userHistory['ãƒãƒ§ã‚­'] > userHistory[mostFrequent]) mostFrequent = 'ãƒãƒ§ã‚­';
            if (userHistory['ãƒ‘ãƒ¼'] > userHistory[mostFrequent]) mostFrequent = 'ãƒ‘ãƒ¼';
            const confidence = (userHistory[mostFrequent] / totalPlays);
             predictions.frequency = {
                choice: mostFrequent,
                confidence: confidence,
                reason: `ã¿ã‚“ãªãŒå‡ºã™æ‰‹ã‹ã‚‰äºˆæ¸¬ (${mostFrequent}ãŒä¸€ç•ªå¤šã„ã­ã€ä¿¡é ¼åº¦: ${confidence.toFixed(2)})`
            };
        }

        if(winLossHistory.length > 0){
            const lastOutcomeForUser = winLossHistory[winLossHistory.length-1][0];
            let relevantHistory = {'ã‚°ãƒ¼': 0, 'ãƒãƒ§ã‚­': 0, 'ãƒ‘ãƒ¼': 0, 'count': 0};
            for(let i = 0; i < winLossHistory.length - 1; i++){
                if(winLossHistory[i][0] === lastOutcomeForUser){
                    const nextUserChoice = winLossHistory[i+1][1];
                    relevantHistory[nextUserChoice]++;
                    relevantHistory['count']++;
                }
            }
            if(relevantHistory['count'] > 1){
                let predicted = 'ã‚°ãƒ¼';
                if (relevantHistory['ãƒãƒ§ã‚­'] > relevantHistory[predicted]) predicted = 'ãƒãƒ§ã‚­';
                if (relevantHistory['ãƒ‘ãƒ¼'] > relevantHistory[predicted]) predicted = 'ãƒ‘ãƒ¼';
                const confidence = (relevantHistory[predicted] / relevantHistory['count']) * (Math.log(relevantHistory['count'] + 1) / Math.log(totalPlays + 2));
                 predictions.winLoss = {
                    choice: predicted,
                    confidence: confidence,
                    reason: `å‰å›${lastOutcomeForUser}ã ã£ãŸå¾Œã®å‚¾å‘ã‹ã‚‰äºˆæ¸¬ (ä¿¡é ¼åº¦: ${confidence.toFixed(2)})`
                };
            } else {
                 predictions.winLoss.reason = `å‰å›${lastOutcomeForUser}ã ã£ãŸå¾Œã®ãƒ‡ãƒ¼ã‚¿ãŒã¾ã å°‘ãªã„ã•ãƒ¼`;
            }
        }

        const randomness = assessOpponentRandomness();
        const patternWeight = gameSettings.metaWeightPattern * (1 - randomness);
        const freqWeight = gameSettings.metaWeightFreq;
        const winLossWeight = gameSettings.metaWeightWinLoss;

        let finalPrediction = null;
        let maxScore = -1;
        let reason = "äºˆæ¸¬ã‚¹ã‚³ã‚¢:";
        const weightedScores = {};

        for(const choice of CHOICES) {
            weightedScores[choice] = 0;
            if(predictions.pattern.choice === choice) weightedScores[choice] += predictions.pattern.confidence * patternWeight;
            if(predictions.frequency.choice === choice) weightedScores[choice] += predictions.frequency.confidence * freqWeight;
            if(predictions.winLoss.choice === choice) weightedScores[choice] += predictions.winLoss.confidence * winLossWeight;
            reason += ` ${choice}:${weightedScores[choice].toFixed(2)} `;
            if (weightedScores[choice] > maxScore) {
                maxScore = weightedScores[choice];
                finalPrediction = choice;
            }
        }

         if (maxScore < 0.1 || !finalPrediction) {
             finalPrediction = predictions.frequency.choice || CHOICES[Math.floor(Math.random() * 3)];
             reason += ` -> ã‚¹ã‚³ã‚¢ä½ã„/äºˆæ¸¬ãªã—ã€é »åº¦/ãƒ©ãƒ³ãƒ€ãƒ æ¡ç”¨`;
         } else {
             reason += ` -> æœ€çµ‚äºˆæ¸¬: ${finalPrediction}`;
         }

         debugLog(`äºˆæ¸¬: P(${predictions.pattern.choice || 'ãªã—'}) F(${predictions.frequency.choice || 'ãªã—'}) W(${predictions.winLoss.choice || 'ãªã—'}) | Rnd:${randomness.toFixed(2)} -> ${finalPrediction || 'ãƒ©ãƒ³ãƒ€ãƒ '}ã«æ±ºå®š`);

        return { predicted: finalPrediction, reason: reason };
    }

    // chooseAIHand é–¢æ•°ã¯å‰å›ã¨åŒã˜ï¼ˆãƒ­ã‚°ã®å£èª¿ã®ã¿å¤‰æ›´ï¼‰
    function chooseAIHand(predictedChoice, predictionReason) {
        let reason = "";
        let aiChoice;

        if (Math.random() < epsilon) {
            aiChoice = CHOICES[Math.floor(Math.random() * 3)];
            reason = `ãˆã„ã£ï¼ãƒ©ãƒ³ãƒ€ãƒ ã§å‡ºã™ã•ãƒ¼ (Îµ=${epsilon.toFixed(3)})`;
        } else {
            if (predictedChoice) {
                aiChoice = COUNTER_MAP[predictedChoice];
                reason = `äºˆæ¸¬(${predictedChoice})ã«å‹ã¤ ${aiChoice} ã‚’å‡ºã™ã•ãƒ¼ï¼ (${predictionReason})`;
            } else {
                aiChoice = CHOICES[Math.floor(Math.random() * 3)];
                reason = `ã†ãƒ¼ã‚“ã€èª­ã‚ãªã„ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã•ãƒ¼ï¼`;
            }
        }
        debugLog(`ã‚­ã‚¸ãƒ ãƒ³ã®æ‰‹: ${aiChoice} (ç†ç”±: ${reason})`);
        return { aiChoice: aiChoice, reason: reason };
    }

    // determineOutcome é–¢æ•°ã¯å‰å›ã¨åŒã˜
    function determineOutcome(userChoice, aiChoice) {
        if (userChoice === aiChoice) {
            return 'å¼•ãåˆ†ã‘';
        } else if (COUNTER_MAP[aiChoice] === userChoice) {
            return 'å‹ã¡';
        } else {
            return 'è² ã‘';
        }
    }

    // updateGameState é–¢æ•°ã¯å‰å›ã¨åŒã˜ï¼ˆãƒ­ã‚°ã®å£èª¿ã®ã¿å¤‰æ›´ï¼‰
    function updateGameState(outcome, userChoice, aiChoice) {
        roundsPlayed++;
        winLossHistory.push([outcome, userChoice, aiChoice]);

        if (outcome === 'å‹ã¡') {
            userWins++;
            userStreak++;
            aiStreak = 0;
            maxUserStreak = Math.max(maxUserStreak, userStreak);
        } else if (outcome === 'è² ã‘') {
            aiWins++;
            aiStreak++;
            userStreak = 0;
            maxAiStreak = Math.max(maxAiStreak, aiStreak);
        } else {
            draws++;
            userStreak = 0;
            aiStreak = 0;
        }

        epsilon = Math.max(gameSettings.minEpsilon, epsilon * gameSettings.epsilonDecay);
         debugLog(`çµæœæ›´æ–°: Round ${roundsPlayed}, çµæœ: ${outcome}, Îµ: ${epsilon.toFixed(3)}`);
    }

    /**
     * æˆ¦ç•¥çš„ãªãƒ–ãƒ©ãƒ•ã‚’ç”Ÿæˆ (ã‚­ã‚¸ãƒ ãƒ³é¢¨)
     */
    function generateStrategicBluff(predictedChoice, lastAiChoice, lastUserChoice, lastOutcome) {
        const bluffs = [];
        bluffs.push(`ã‚­ã‚¸ãƒ ãƒ³: æ¬¡ã¯ãŠã„ã‚‰ã€${CHOICES[Math.floor(Math.random() * 3)]}ã‚’ã ã™ã‚ˆï½ï¼`);

        if(predictedChoice){
             bluffs.push(`ã‚­ã‚¸ãƒ ãƒ³: ãµã‚€ãµã‚€ã€æ¬¡ã¯${predictedChoice}ã§æ¥ã‚‹ã¯ãšã•ãƒ¼ï¼`);
             bluffs.push(`ã‚­ã‚¸ãƒ ãƒ³: ${predictedChoice}ã«ã¯ã€${COUNTER_MAP[predictedChoice]}ã•ãƒ¼ï¼ã“ã‚Œã©ã†ï¼Ÿ`);
        }
        if(lastOutcome === 'è² ã‘' && lastUserChoice){
             bluffs.push(`ã‚­ã‚¸ãƒ ãƒ³: ã†ããã€ã•ã£ãã®${lastUserChoice}ã¯å¼·ã‹ã£ãŸã•ãƒ¼ï¼`);
             bluffs.push(`ã‚­ã‚¸ãƒ ãƒ³: åŒã˜æ‰‹(${lastUserChoice})ã«ã¯ã‚‚ã†å¼•ã£ã‹ã‹ã‚‰ãªã„ã‚ˆãƒ¼ï¼`);
        }
         if(lastOutcome === 'å‹ã¡' && lastAiChoice){
             bluffs.push(`ã‚­ã‚¸ãƒ ãƒ³: ${lastAiChoice}ãŒæ±ºã¾ã£ãŸã­ãƒ¼ï¼ã‚‚ã†ä¸€å›ã„ãã•ãƒ¼ï¼Ÿ`);
         }
         if(aiStreak >= 2){
              bluffs.push(`ã‚­ã‚¸ãƒ ãƒ³: ${aiStreak}é€£å‹ã•ãƒ¼ï¼ ãŠã„ã‚‰çµ¶å¥½èª¿ã ã‚ˆãƒ¼ï¼`);
         }
         if(userStreak >= 2){
              bluffs.push(`ã‚­ã‚¸ãƒ ãƒ³: ${userStreak}é€£å‹ã¨ã¯ã‚„ã‚‹ã­ãƒ¼ï¼ã§ã‚‚ã€æ¬¡ã¯ãŠã„ã‚‰ãŒå‹ã¤ã•ãƒ¼ï¼`);
         }

        strategicBluff = bluffs[Math.floor(Math.random() * bluffs.length)];
        debugLog(`ãƒ–ãƒ©ãƒ•: ${strategicBluff}`);
    }


    /**
     * UIã‚’æ›´æ–°ã™ã‚‹ (ã‚­ã‚¸ãƒ ãƒ³é¢¨ãƒ†ã‚­ã‚¹ãƒˆ)
     */
    function updateUI(outcome, userChoice, aiChoice) {
        let imgSrc, statusColor;
        let outcomeText = outcome;

        if (outcome === 'å‹ã¡') {
            imgSrc = IMG_SAD; statusColor = '#ef4444'; outcomeText = "ã‚ãªãŸã®å‹ã¡ï¼";
        } else if (outcome === 'è² ã‘') {
            imgSrc = IMG_HAPPY; statusColor = '#3b82f6'; outcomeText = "è² ã‘ã¦ã—ã¾ã£ãŸâ€¦";
        } else if (outcome === 'å¼•ãåˆ†ã‘') {
            imgSrc = IMG_THINK; statusColor = '#6b7280'; outcomeText = "å¼•ãåˆ†ã‘ï¼";
        } else {
             imgSrc = IMG_THINK; statusColor = '#333';
             outcomeText = outcome;
        }
        faceEl.src = imgSrc;
        statusTextEl.textContent = outcomeText;
        statusTextEl.style.color = statusColor;

       
        // ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤º
        if (userChoice && aiChoice) {
            resultEl.textContent = `ã‚ãªãŸ: ${userChoice} vs ã‚­ã‚¸ãƒ ãƒ³: ${aiChoice}`;
            // æ‰‹ç”»åƒã‚’å·®ã—æ›¿ãˆ
            userHandEl.src = USER_HAND_IMAGES[userChoice] || '';
            aiHandEl.src   = AI_HAND_IMAGES[aiChoice]   || '';
        } else {
            resultEl.textContent = `ã‚ãªãŸ vs ã‚­ã‚¸ãƒ ãƒ³`;
            // ãƒ©ã‚¦ãƒ³ãƒ‰å‰ã¯ã‚¯ãƒªã‚¢
            userHandEl.src = '';
            aiHandEl.src   = '';
        }

        historyEl.textContent = `å±¥æ­´: å‹ã¡(${userWins}), è² ã‘(${aiWins}), ã‚ã„ã“(${draws})`;

        const total = userWins + aiWins + draws;
        const userRate = total > 0 ? (userWins / total * 100).toFixed(1) : '0.0';
        const aiRate = total > 0 ? (aiWins / total * 100).toFixed(1) : '0.0';
        statsInfoEl.innerHTML =
          `å‹ç‡: ã‚ãªãŸ ${userRate}% / ã‚­ã‚¸ãƒ ãƒ³ ${aiRate}%<br>` +
          `æœ€å¤§é€£å‹: ã‚ãªãŸ ${maxUserStreak} å›, ã‚­ã‚¸ãƒ ãƒ³ ${maxAiStreak} å›<br>` +
          `ç¾åœ¨ã®ãƒ‘ã‚¿ãƒ¼ãƒ³é•·: ${currentMaxPattern} (Îµ: ${epsilon.toFixed(3)})`;

        // ã‚°ãƒ©ãƒ•æ›´æ–°
        if (statsChart && userHistChart) { // ãƒãƒ£ãƒ¼ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
            statsChart.data.datasets[0].data = [userWins, aiWins, draws];
            statsChart.update();
            userHistChart.data.datasets[0].data = [userHistory['ã‚°ãƒ¼'], userHistory['ãƒãƒ§ã‚­'], userHistory['ãƒ‘ãƒ¼']];
            userHistChart.update();
        }

        // AIæ€è€ƒè¡¨ç¤º
        aiReasoningEl.textContent = aiReasoning;
        aiReasoningEl.style.visibility = showReasoningCheckbox.checked ? 'visible' : 'hidden';
        aiReasoningEl.style.opacity = showReasoningCheckbox.checked ? '1' : '0';

        // ãƒ–ãƒ©ãƒ•è¡¨ç¤º
        bluffEl.textContent = strategicBluff;
    }

    /**
     * ã‚²ãƒ¼ãƒ çµ‚äº†ã‹ãƒã‚§ãƒƒã‚¯ (ã‚­ã‚¸ãƒ ãƒ³é¢¨ãƒ†ã‚­ã‚¹ãƒˆ)
     */
     function checkGameEnd() {
    if (userWins >= WIN_TARGET || aiWins >= WIN_TARGET) {
        // ãƒœã‚¿ãƒ³ã‚’å…¨éƒ¨ç„¡åŠ¹åŒ–
        choiceBtns.forEach(btn => btn.disabled = true);

        // å‹è€…ã‚’åˆ¤å®š
        const winner = userWins >= WIN_TARGET ? 'ã‚ãªãŸ' : 'ã‚­ã‚¸ãƒ ãƒ³';

        // 1) æ”¹è¡Œå…¥ã‚Šã§ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º
        statusTextEl.innerHTML = `å‹è² ã‚ã‚Šï¼<br>${winner}ã®å‹ã¡ã•ãƒ¼ï¼`;
        statusTextEl.style.color = winner === 'ã‚ãªãŸ' ? '#ef4444' : '#3b82f6';

        // 2) å‹è€…ã«å¿œã˜ãŸæœ€çµ‚ç”»åƒã‚’ã‚»ãƒƒãƒˆ
        faceEl.src = winner === 'ã‚ãªãŸ' ? IMG_FINAL_USER : IMG_FINAL_AI;

        // 3) ãƒ–ãƒ©ãƒ•ãƒ†ã‚­ã‚¹ãƒˆï¼†AIæ€è€ƒã¯ãã®ã¾ã¾æ›´æ–°
        bluffEl.textContent = winner === 'ã‚ãªãŸ'
            ? "ã‚­ã‚¸ãƒ ãƒ³: ã‚ãƒ¼ï¼è² ã‘ã¡ã‚ƒã£ãŸã•ãƒ¼ï¼ã™ã”ã„ã­ãƒ¼ï¼"
            : "ã‚­ã‚¸ãƒ ãƒ³: ã‚„ã£ãŸãƒ¼ï¼ãŠã„ã‚‰ã®å‹ã¡ã•ãƒ¼ï¼";
        aiReasoning = "ã‚²ãƒ¼ãƒ çµ‚ã‚ã‚Šã•ãƒ¼ï¼";

        // ãƒ­ã‚°å‡ºåŠ›
        debugLog(`ã‚²ãƒ¼ãƒ çµ‚äº†ã•ãƒ¼ã€‚å‹è€…: ${winner}`);
        return true;
    }
    return false;
}



    /**
     * 1ãƒ©ã‚¦ãƒ³ãƒ‰å®Ÿè¡Œ (å‰å›ã¨åŒã˜)
     */
    function playRound(userChoice) {
    debugLog(`--- Round ${roundsPlayed + 1} é–‹å§‹ã•ãƒ¼ ---`);
    debugLog(`ã‚ãªãŸã®æ‰‹: ${userChoice}`);

    updateGameHistory(userChoice);
    detectStrategyChange();
    updateDynamicMaxPattern();

    // --- â‘  ç¾åœ¨ãƒ©ã‚¦ãƒ³ãƒ‰ã® AI ã®æ‰‹ã‚’æ±ºã‚ã‚‹ ---
    let aiDecision;
    if (committedAiChoice) {
        // å‰å›ç´„æŸã—ãŸæ‰‹ã‚’ãã®ã¾ã¾å‡ºã™
        aiDecision = {
        aiChoice: committedAiChoice,
        reason: ``
        };
        debugLog(`ã‚­ã‚¸ãƒ ãƒ³ã®æ‰‹ (ç´„æŸ): ${aiDecision.aiChoice}`);
    } else {
        // åˆå›ãƒ©ã‚¦ãƒ³ãƒ‰ã‹ç´„æŸãŒãªã„å ´åˆã¯é€šå¸¸ãƒ­ã‚¸ãƒƒã‚¯
        const prediction = predictUserChoice();
        aiDecision = chooseAIHand(prediction.predicted, prediction.reason);
    }

    const outcome = determineOutcome(userChoice, aiDecision.aiChoice);
    updateGameState(outcome, userChoice, aiDecision.aiChoice);

    // --- â‘¡ æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ã§å‡ºã™æ‰‹ã‚’äºˆæ¸¬ã—ã¦ã‚³ãƒŸãƒƒãƒˆ ---
    const nextPrediction = predictUserChoice();
    const nextAiDecision = chooseAIHand(nextPrediction.predicted, nextPrediction.reason);
    committedAiChoice = nextAiDecision.aiChoice;  // â† ã“ã“ã§ç´„æŸ

    // â€œæ¬¡æˆ¦ã§ã¯ã€‡ã€‡ã‚’å‡ºã™äºˆå®šã•ãƒ¼ï¼â€ ã®ã¿è¡¨ç¤º
    aiReasoning = `æ¬¡æˆ¦ã§ã¯${committedAiChoice}ã‚’å‡ºã™äºˆå®šã•ãƒ¼ï¼`;;

    updateUI(outcome, userChoice, aiDecision.aiChoice);

    if (!checkGameEnd()) {
        generateStrategicBluff(/*â€¦æ—¢å­˜å¼•æ•°â€¦*/);
        bluffEl.textContent = strategicBluff;
    }
    debugLog(`--- Round ${roundsPlayed} çµ‚äº†ã•ãƒ¼ ---`);
    }


    // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ (å‰å›ã¨åŒã˜) ---
    choiceBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        playRound(btn.dataset.choice);
      });
    });

    difficultySelect.addEventListener('change', initGame); // é›£æ˜“åº¦å¤‰æ›´æ™‚ã«initGameã‚’å‘¼ã³å‡ºã™

    showReasoningCheckbox.addEventListener('change', ()=>{
         aiReasoningEl.style.visibility = showReasoningCheckbox.checked ? 'visible' : 'hidden';
         aiReasoningEl.style.opacity = showReasoningCheckbox.checked ? '1' : '0';
    });


    // --- ã‚²ãƒ¼ãƒ é–‹å§‹ ---
    // DOMContentLoaded ã‚’å¾…ã£ã¦ã‹ã‚‰åˆæœŸåŒ–ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´
    document.addEventListener('DOMContentLoaded', (event) => {
        initGame();
    });


  </script>
</body>
</html>
